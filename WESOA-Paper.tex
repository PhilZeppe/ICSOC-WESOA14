\documentclass{llncs}

\usepackage{makeidx}


\usepackage[pdftex]{graphicx}
\usepackage[cmex10]{amsmath}
\usepackage{algorithmic}
\usepackage{array}
\usepackage{mdwmath}
\usepackage{mdwtab}
\usepackage{eqparbox}
\usepackage[caption=false,font=footnotesize]{subfig}
\usepackage{fixltx2e}
\usepackage{stfloats}
\usepackage{url}
  
\usepackage{soul} %color and soul are for highlihting while working on the paper
\usepackage{color}
\usepackage{paralist} %for inpapaenum
\usepackage{float}    %for fixing floats
\usepackage{placeins} %for fixing floats
\usepackage{gensymb}  %for degree symbol

%\usepackage{hyperref} % REMOVE THIS AGAIN AFTERWARDS

\hyphenation{crowd-sour-cing middle-ware uni-dir-ection-al inter-mittently end-points}

\DeclareFontFamily{\encodingdefault}{\ttdefault}{\hyphenchar\font=`\-} %enable hyphenation of \texttt{} text

%\newcommand{\sms}{\textsc{SmartSoc}}
\newcommand{\mdl}{\textsc{SmartCom}}

%Make figures easier
\newcommand{\figfloat}[3][0.9]{
\begin{figure}[h] 
\centering
\includegraphics[width=#1\textwidth]{figures/#2}
\caption{#3}
\label{fig:#2}
\end{figure}
}

\newcommand{\figtop}[3][0.9]{
\begin{figure*}[h]
\centering
\includegraphics[width=#1\textwidth]{figures/#2}
\caption{#3}
\label{fig:#2}
\end{figure*}
}
\newcommand{\figtopl}[4][0.9]{
\begin{figure*}[h]
\centering
\includegraphics[width=#1\textwidth]{figures/#2}
\caption{#4}
\label{fig:#3}
\end{figure*}
}


\begin{document}
%
\pagestyle{headings}  % switches on printing of running heads

%
% paper title
% can use linebreaks \\ within to get better formatting as desired
\title{Virtualizing Communication for Hybrid and Diversity-Aware Collective Adaptive Systems}
\titlerunning{Virtualizing Communication for HDA-CAS}
\author{Philipp Zeppezauer \and Ognjen Scekic \and Hong-Linh Truong \and Schahram Dustdar}

\institute{Distributed Systems Group, Vienna University of Technology, Austria\\
\email{Email: \{zeppezauer,oscekic,truong,dustdar\}@dsg.tuwien.ac.at}}

% make the title area
\maketitle


\begin{abstract}

Hybrid and Diversity-Aware Collective Adaptive Systems (HDA-CAS) form a broad class of highly distributed systems comprising a number of heterogeneous human-based and machine-based computing (service) units. These units collaborate in ad-hoc formed, dynamically-adaptive collectives. The flexibility of these collectives makes them suitable for processing elaborate tasks, but at the same time, building a system to support diverse communication types in such collectives is challenging. In this paper, we address the fundamental communication challenges for HDA-CAS. We present the design of a middleware for virtualizing communication  within and among collectives of diverse types of service units. The middleware is able to handle numerous, intermittently available, human and software-based service units, and manages the notion of collectivity transparently to the programmer. A prototype implementation for validation purpose is also provided.

\end{abstract}

\section{Introduction}
\label{sec:intro}

  \textit{Collective Adaptive System} (\textit{CAS}) \cite{FoCASBook} is an umbrella-term denoting distributed systems comprised of multiple autonomous computing/service units with different individual properties, but with the fundamental property of collectiveness. \emph{Collectiveness} implies that the individual units need to communicate and collaborate in order to reach common decisions, or perform tasks jointly. \emph{Adaptiveness} is another basic property of CASs, implying open systems where  units may join and leave, and dynamically alter collective compositions or task execution goals. 
  %
  CASs come in a variety of forms. \textit{Hybrid and Diversity-Aware CASs} (\textit{HDA-CAS}s)~\cite{fausto} additionally add the \emph{heterogeneity} to the founding principles. This means that they inherently support communication and collaboration among different types of units, such as software, people and sensors. 

  \textbf{Motivation. }
  %
  Let us consider a smart-city \emph{maintenance provider} (\emph{MP}) -- a company running a monitoring center covering thousands of sensors and equipment systems geographically dispersed in numerous smart buildings (e.g., Galaxy\footnote{Pacific Controls Galaxy. \url{http://www.pacific-galaxy.com/}}). The MP provides the centralized service of both \emph{predictive} and \emph{corrective} maintenance to its customers (building/equipment owners/tenants). This means that MP control centers actively monitor events originating from various sensors and perform Complex Event Processing on these data flows. If a potential or actual malfunction is detected they dispatch collectives of experts to analyze the situation in detail, and, if necessary, perform the physical maintenance work on the ground. The (human) experts are contracted to work on-demand with the MP, subject to their availability.
  %
  Since each equipment manufacturer defines different issue analysis and reparation procedures, when equipment from different manufacturers is interconnected in a smart building, detecting the cause of an anomaly event sequence cannot easily be done by following prescribed procedures. The complexity grows further when considered at the scale of a smart city, with thousands of building, each with a unique equipment mix, age, environment, and agreed service-level. Therefore, such a scenario does not lend itself well to a conventional workflow type of orchestration. Rather, collectives of human experts perform loosely-controlled collaboration patterns (Section~\ref{sec:intro:context}) in order to detect and repair the problem in the most efficient way, considering the particular context, and making use of supporting software tools when needed (e.g., for data analysis, communication). 

  \textbf{Contribution. }
  %
  In the described motivational scenario the MP needs a platform to communicate with, deploy and orchestrate ad-hoc assembled, dynamic teams of human-based and machine-based service units in order to execute, often unpredictable, complex collaboration patterns. A HDA-CAS, as the one being researched in \textit{SmartSociety} project \cite{SmartSocBook}, can support these  requirements. In this paper, we present the design of one of the SmartSociety's core components: the \emph{virtualization and communication middleware} -- \mdl{}, providing the communication and virtualization primitives to support heterogeneity, collectivity and adaptiveness. \mdl{} is actually an independent component usable with a wide number of HDA-CAS platforms.
  %
   \mdl{} fulfils the following characteristic of most service buses:
     \begin{inparaenum}[a) \itshape]
        \item \textit{Heterogeneity} -- supporting various types of communications channels (protocols) between the platform and service units as well as among service units/collectives, transparently to the HDA-CAS platform user.
        \item \textit{Communication} -- providing primitives for: message transformation, routing, delivery with configurable options (e.g., retries, expiry, delayed, acknowledged).
        \item \textit{Persistence} -- message persistence and querying.
        \item \textit{Security} -- Handling authentication and encryption, as well as preventing message flooding.
        \item \textit{Scalability} -- ability to handle large number of intermittently available service units.
      \end{inparaenum}

	In addition to these features, the distinguishing novelty of \mdl{} is its native support for virtualizing \text{collectives}: 
	\begin{inparaenum}[i) \itshape]
		\item \mdl{} hides the complexity of communication with a dynamic collective as a whole and passing of instructions from the HDA-CAS execution engine to it, making it a first-class, programmable entity; 
		\item  Communication with the collective members is transparent to the HDA-CAS, regardless of whether they are human or machine-based, with \mdl{} interpreting the messages for the human-based service units; 
		\item  A single human, sensor or software service endpoint can participate in different collectives concurrently, acting as a different service unit with different SLA, delivery and privacy policies. 
	\end{inparaenum}
	These novel properties make \mdl{} especially suitable for supporting scenarios such as predictive maintenance. To the best of our knowledge, no other platforms or middleware systems offer the collective virtualization in a similar manner. 

%\figtop[.85]{smartsoc-highlevel}{Operational context for the \mdl{} middleware. Middleware components are marked in blue.}
\figtopl[.85]{bw/smartsoc-highlevel}{smartsoc-highlevel}{Operational context for the \mdl{} middleware. Middleware components are marked with thick lines.}

\textbf{Paper Organization. }
  %
  In the following section we present the operational context of the \mdl{} middleware. In Section~\ref{sec:middleware} we present \mdl's architecture and design choices. In Section~\ref{sec:impl} we  describe the implementation and illustrates a realistic use-case. Section~\ref{sec:relwork} presents the related work. Section~\ref{sec:conclusion} concludes the paper.

  \section{Operational Context of Collective Communication}
    \label{sec:intro:context}

      Figure~\ref{fig:smartsoc-highlevel} shows the high-level architecture of the SmartSociety platform and presents \mdl's operational context. SmartSociety platform supports `programming' and execution of hybrid human-computer `computations'. These computations consist of different general-purpose tasks being submitted to the platform for execution. More precisely, the platform \emph{users} (e.g., a smart-city maintenance provider) submit complex tasks to a \emph{SmartSociety application} running on the platform. The application performs the task by assembling and engaging \textbf{collectives} of \textbf{service units} to execute the (sub-)tasks collaboratively.

      The service unit (SU) is an entity provisioned and utilized through service models (e.g., on-demand and pay-per-use use), as described in \cite{truongijcis}. An SU consists of:
        \begin{inparaenum}[\itshape i)]
          \item \textit{Peer} -- a human, a machine, or a thing (e.g., a sensor) performing the computation or executing a task;
          \item \textit{Context} -- a set of parameters describing the execution context of the particular HDA-CAS application in which the SU is participating. 
        \end{inparaenum}
      %
      The context parameters can include: execution ID, QoS requirements, performance metrics, associated incentives. 
	  %Additionally, the context includes a \emph{Communication Adapter}, a component belonging to the \mdl{} middleware, providing a context/application-dependent communication and virtualization channel for communicating with the SU, 
	  To describe the communication with a SU, the context comprises the \emph{Communication Context} part which defines the context-dependent communication and virtualization channels (e.g., using email, SMS).
      %
      The SU can use different communication channels to interact with \mdl{}, e.g., a human-based SU can communicate with the platform via email and Twitter interchangeably, receive task descriptions and track progress through a web application, and communicate with other SUs within the collective through a dedicated mobile app. Human-based SUs can make use of software-based SUs in the collective, serving as collaborative and utility tools. For example, a software service like Doodle can be used to agree upon participation times, Dropbox as a common repository for performed tasks, or Splunk for data analytics.

      Both humans and machines can drive the task processing---e.g., a software may invoke workflow activities which are performed by  human-based service units; or, conversely, human-based service units can orchestrate the execution independently, using software services as data analytics, collaboration and coordination tools.
      %
      How exactly a task is processed is effectively controlled by the SmartSociety application.  As an important design principle of the SmartSociety platform is to achieve `smartness' by leveraging human intelligence and capabilities whenever possible, the applications try to minimize the use of conventional workflows to describe the task processing, and rely primarily on the use of \emph{collaboration patterns}. 
      %
      A collaboration pattern governs the effort within a collective in a loose manner; rather than over-regulating humans, the collaboration patterns set the limits within which the service units are allowed to self-organize, using familiar collaboration tools and environments. 
      
      A collaboration pattern consists of the following elements:
      \begin{inparaenum}[1) \itshape]%[\setlabelwidth{-}]
		%
		\item \emph{Relationship topology} -- specifying different topologies (e.g., independent, tree, ring, sink, random) and relation types formalizing relationships among service units in a collective. The meaning of the relations is application specific, and can be used to express communication/data/command flow. 
		%
		\item \emph{Collaboration environment} -- specifying access to familiar external tools that the service units can use to collaborate among themselves (e.g., Google Docs, Dropbox). When a collective is formed, service units are provided with instructions and appropriate access credentials for the previously set up collaboration environment. 
		%
		\item \emph{Communication channels} -- analogously to the collaboration environment, the pattern should specify access to familiar external tools that the service units can use to communicate among themselves and with SmartSociety Platform. 
		%
		\item \emph{Elasticity policies} -- definitions of metrics to be monitored and algorithms for collective composition and adaptation.
		%
		\item \emph{Security and privacy policies} -- policies to restrict communication to specific (sub-)collective or to predefined communication channels.
	  \end{inparaenum}

  \figfloat[1.]{smartcom-architecture}{Simplified architecture of the \mdl{} middleware.}
          %\FloatBarrier

  \section{Middleware Design and Architecture}
  \label{sec:middleware}

  Figure~\ref{fig:smartcom-architecture} shows the conceptual architecture of the \mdl{} middleware. The \emph{HDA-CAS Platform} components (e.g., executing application modules) pass the messages intended for collectives to the \emph{Communication Engine} through a public API. The task of the Communication Engine is to effectively virtualize the notions of `collective' and `service unit (SU)' for the HDA-CAS platform. This means that the communication with different service units and collectives has to be handled transparently to the HDA-CAS platform, independent of unit's actual type and availability. 
  %Communication engine's principal components are the Messaging and Routing Manager and the Adapter Manager.
  In the following sections, for brevity, when referring to the communicational aspect of SU's functionality we will use the short term ``peer'' denoting the computing human/machine element within the SU that is the sender or receiver of information/data; and the term ``adapter'' denoting the middleware component in charge of handling the communication.

  \textbf{Messaging and Routing. }
    %
    All communication between the peers and the platform is handled asynchronously using normalized messages. A queue-based \emph{Message Broker} is used to decouple the execution of \mdl's components and the communication with peers. 
    %
    \mdl{} supports unicast as well as multicast messages. Therefore, multiple peers can also be addressed as collectives and the \mdl{} will take care of sending the message to every single member of the collective. 
    %
	
    The \emph{Messaging and Routing Manager} (MRM) is \mdl's principal entry point for HDA-CASs. It consists of the following components:
    \begin{inparaenum}
      \item The \emph{Message Handler} takes incoming messages from HDA-CAS and transforms them into an internal representation. If the receiver of the message is a collective, it resolves the current member peers, and their preferred communication channels; 
      %
      \item The \emph{Routing Rule Engine} then determines the proper route to the peers, invoking the Adapter Manager to instantiate appropriate adapters in order to complete the route, if needed (see below); 
      %
      \item The \emph{Feedback Handler} waits for feedback messages received through feedback adapters and  passes them to the Message Handler. Afterwards they will be handled like normal messages again, and re-routed where needed, e.g., back to the HDA-CAS.
    \end{inparaenum}
	%    
    A \emph{route} may include different communication channels as delivery start-/endpoints. Figure~\ref{fig:routes} shows the conceptual overview of \mdl's routing. For each message the route will be determined by the Routing Rule Engine using the pipes-and-filters pattern, determining the route based on the  message properties: receiver ID, message type and message subtype, with decreasing priority. 
	  % 
    Note that there may be multiple routes per message (e.g., a single peer can be contacted using a mobile app, email and SMS concurrently).

    \figfloat[.75]{routes}{Messages are routed to Peer Adapters ($P_a$) which forward the messages to the corresponding Peers ($P_1$ to $P_5$). Feedback is sent back by human peers, software peers (e.g., Dropbox) and sensors using Feedback Adapters ($F_a$). The HDA-CAS Platform can also send and receive messages.}

  \textbf{Adapters. }
  	%
    In order to use a specific communication channel, an associated \emph{adapter} needs to be instantiated. The communication between peers and the adapters is unidirectional --- \emph{peer adapters} are used to send messages to the peers; \emph{feedback adapters} are used to receive messages from peers. 
    %
    \mdl{} originally provides some common peer/feedback adapters  (e.g., SMTP/POP, Dropbox, Twitter). In addition, being developed in the context of a research project, it also provides adapters for dedicated SmartSociety Android/Web peer apps. 
    %When an HDA-CAS requires the \mdl{} to handle a new communication channel, it needs to provide an appropriate adapter implementation. Afterwards, \mdl{} will instantiate the new adapter when needed.
    The role of adapters should be considered from the following two perspectives:
    \begin{inparaenum}[\itshape 1)]
    \item functional; and 
    \item technical.
    \end{inparaenum}
    
    Functionally, the adapters allow for:
    \begin{inparaenum}[\itshape a)]
    \item Hybridity -- by enabling different communication channels to and from peers;
    \item Scalability -- by enabling \mdl{} to cater to the dynamically changing number of peers;
    \item Extensibility -- new types of communication and collaboration channels can easily be added at a later stage transparently to the rest of the HDA-CAS platform.
    \item Usability -- human peers are not forced to use dedicated applications for collaboration, but rather freely communicate and (self-)organize among themselves by relying on familiar third-party tools.
    \item Load Reduction and Resilience -- by requiring that all the feedback goes exclusively and unidirectionally through external tools first, only to be channelled/filtered later through a dedicated feedback adapter, the \mdl{} is effectively shielded from unwanted traffic load, delegating the initial traffic impact to the infrastructure of the external tools. At the same time, failure of a single adapter will not affect the overall functioning of the middleware.
    \end{inparaenum}

    %For example, the peer might upload a 5MB photo to his Dropbox folder, while \mdl{} will just notify the send one simple msg through the middleware}).

    % \figfloat[0.85]{api}{Partial representations of the \mdl's APIs and message flow.}

    Technically, the primary role of adapters is to perform the message format transformation. Optional functionalities include: message filtering, aggregation, encryption, acknowledging and delayed delivery. Similarly, the adapters are used to interface \mdl{} with external software services, allowing the virtualization on third party tools as common software peers.
    %
    The \emph{Adapter Manager} is the component responsible for managing the adapter lifecycle (i.e., creation, execution and deletion of instances), elastically adjusting the number of active instances from a pool of available adapters. This allows scaling the number of active adapter instances out as needed. This is especially important when dealing with human peers, due to their inherent periodicity, frequent instability and unavailability, as well as for managing a large number of connected devices, such as sensors. The Adapter Manager consists of following subcomponents: 
    %Adapter Handler, Adapter Execution Engine and Address Resolver.
    %
    \begin{itemize}[$\bullet$]
      \item \emph{Adapter Handler}: managing adapter instance lifecycle. It handles the following adapter types:  
            \begin{inparaenum}[\itshape i)]
              \item Stateful peer adapters -- peer adapters that maintain conversation state (e.g., login information). For each peer a new instance of the adapter will be created; 
              %
              \item Stateless peer adapters -- peer adapters that maintain no state. An instance of an adapter can send messages to multiple peers; 
              %
              \item Feedback pull adapters -- adapters that actively poll software peers for feedback. They are created on demand by applications running on the HDA-CAS platform and will check regularly for feedback on a given communication channel (e.g., check if a file is present on an FTP server);
              %
              \item Feedback push adapters -- adapters that wait for feedback from peers. 
            \end{inparaenum}
      \item \emph{Adapter Execution Engine}: executing the active adapters.
      \item \emph{Address Resolver}: mapping adapter instances with peers' external identifiers (e.g., Skype/Twitter username) in order to initiate the communication.
    \end{itemize}
	%
    Feedback messages from peers (e.g., subtask results) or external tools (e.g., Dropbox file added, email received on a mailing list) are consumed by the adapters either by a push notification or by pulling in regular intervals (more details in Section~\ref{sec:impl}). 
    %
    Due to space constraints, a detailed description of the described architectural components and their implementation, as well as the full API specification is provided in the supplement materials\footnote{\url{https://github.com/tuwiendsg/SmartCom/wiki}}.

  \textbf{Other Functionalities.}
    %
    All sent and received messages as well as internal messages are persisted in a NoSQL database. Stored messages can be queried and analyzed through the \emph{MessageQuery} public API (e.g., to derive metrics or identify conditions for applying incentives).
    %
    Since messages can be of arbitrary subtype and contain an arbitrary payload, human peers (and their local third-party applications) might not know how to interpret the message. The \emph{MessageInfoService} provides:
    \begin{inparaenum}[\itshape a)]
        \item The semantic meaning/description of message type and contents in a human-readable way; 
        \item Dependencies to other messages;
        \item Timing constraints (e.g., expiry, priority).
    \end{inparaenum}
    %
    This is especially useful when supporting complex task acceptance negotiations, where human peers are required to fully understand the message meaning and send back valid answers. 
    %
    Currently, the service annotates the message field types, provides a natural-language description of the expected fields contents and provides a state-machine description describing the allowed message exchange sequence with respect to dependency and timing constraints. The \emph{MessageInfoService} can also be extended to provide an ontology of message types enabling machine-readable message descriptions, and use of personal software agents searching for tasks and participating in negotiations on behalf of human peers \cite{KobiGal}. 

    \mdl{} supports specifying and observing delivery and privacy policies on message, peer and collective level: 
	\emph{Delivery policies} stipulate how to interpret and react to possible communication exceptions, such as: failed, timed out, unacknowledged or repeated  delivery. \emph{Privacy policies} restrict sending or receiving messages or private data to/from other peers, collectives or HDA-CAS applications under different circumstances. 
	%
	Apart from offering predefined policies, \mdl{} also allows the users to import custom, application- or peer-specific policies. 
	%
	As noted, both types of policies can be specified at different levels. For example, a peer may specify that he can be reached only by peer `manager' via communication channel `email', from 9am to 5pm in collective `Work'. The same person can set to be reachable via `SMS' any time by all collective members except `manager' in collective `Bowling'.
	Similarly, a HDA-CAS platform application could specify the collective delivery policy stating that when sending instructions to a collective it suffices that the delivery to a single member succeeds to consider the overall delivery successful on the collective level. \mdl{} takes care of combining and enforcing these policies transparently to the HDA-CAS user in different collective contexts.

 	Peer authentication is handled externally. Before instantiating the corresponding adapter, \mdl{} requires the peers to authenticate with the external tool and obtains from the tool the token that is used to authenticate messages from/to the peer. More information is provided in the supplement materials.
      
\section{Implementation \& Illustrative Example}
\label{sec:impl}

	\mdl{} prototype was implemented in the Java programming language and can be used directly by HDA-CAS platforms running on the Java Virtual Machine. Additionally, other platforms can interact with \mdl{} using the set of provided APIs. 
	The prototype comes with some implemented standard adapters (e.g., Email, Twitter, Dropbox) that can be used to test, evaluate and operate the system.
	Additional third-party adapters can be loaded as plug-ins and instantiated when needed.
	\mdl{} uses MongoDB\footnote{\url{http://www.mongodb.org}} as a database system for its various subsystems. Depending on the usage of the middleware, either an in-memory or dedicated database instances of MongoDB can be used. To decouple the execution of the HDA-CAS platform and the communication we use Apache ActiveMQ\footnote{\url{http://activemq.apache.org}} as the message broker.
	%
	The source code, as well as runnable integration tests showcasing the usage and functioning of the middleware can be found in \mdl's GitHub repository\footnote{\url{https://github.com/tuwiendsg/SmartCom}}. The various subsystems and the whole system can be built using Maven. The APIs are provided in the \texttt{api} module. Additional documentation regarding the design, implementation and usage is provided on the repository's Wiki page. 

	Based on the motivating scenario presented in Section~\ref{sec:intro} we formulate a concrete use-case to validate the presented design and its fulfilment of the stated requirements:
	%
	\emph{A predictive maintenance SmartSociety application receives sensor readings from a smart building and performs Complex Event Processing (CEP) on them. If an indication of a potential malfunction is detected, further investigation is required. A collective (COL1) of available human experts is formed\footnote{Selection of collective peers is out of scope of this paper.} and a collaborative pattern imposed (Section~\ref{sec:intro:context}). The application appoints an expert to lead the peer collaboration within the collective and sets up a Dropbox repository for sharing the findings and equipment logs between the SmartSociety application and the collective. Additionally, it provides to the COL1 manager the contact details of the manufacturer of the malfunctioning equipments in case additional consultations are required. Finally, \mdl{} also provides COL1 peers with mediated access to a data analysis tool (e.g., Splunk\footnote{\url{www.splunk.com}}).}

	\figfloat[.8]{use-case}{Supporting predictive maintenance use-case. Collectives of human expert and software service units participate in a joint collaboration to identify the cause of a detected malfunction event.}

	Figure~\ref{fig:use-case} shows the two collectives participating in this scenario. COL1 containing human expert service units (SUs) and a single software SU --- the Dropbox service. Furthermore, each human SU is assigned a dedicated peer adapter ($P_a$) instance, while for the Dropbox service, both a $P_a$ and a feedback adapter ($F_a$) instance are executed, in order to support two-way communication with the SmartSociety platform. COL2 contains a single SU that does data analysis. To support two-way communication we introduce again a $P_a$ and a $F_a$.

	The use-case starts by SmartSociety application notifying peers that their participation is needed (Fig.~\ref{fig:use-case}, \texttt{1}\degree) by sending a message to \texttt{MessagingAndRoutingManager} which will initialize the routing. Some peers expressed in their profiles the preference for being notified by SMS, others by email. To send an SMS \texttt{MessagingAndRoutingManager} reads the phone number of a peer from its profile and hands it to \texttt{AdapterManager} which instantiates and executes the SMS adapter. \texttt{PeerAdapter} sends the message by using the most cost-efficient mobile operator. Those peers that prefer to be contacted through email will be sent an email using a stateless email adapter through an external mail service. This preference can be set using \texttt{DeliveryPolicy}.
	%
	The contents of the message are provided by the SmartSociety application. In this case, the message contains the URL pointing to the description of the detected event, Dropbox repository URL and access tokens for sharing the results, the name and contact details of the selected collective manager as well as a natural language description of the required activities and contractual terms. Furthermore, the manager is sent the contact details of the equipment manufacturer's customer service, and the address of another collective -- COL2, which in practice contains a single software peer, the Splunk service.

	For the sake of simplicity, we assume that expert peers do accept the terms and participate in COL1. The manager freely organizes the collaboration in COL1. At a certain point, human peers need to run an additional data analysis on the log. The collaboration pattern foresees that if a file with predefined filename is deposited in the shared Dropbox repository, the dedicated feedback adapter would pick up that file (\texttt{2}\degree) and forward it to the COL2 for analysis. The middleware ensures that \texttt{FeedbackPullAdapter} for Dropbox \texttt{(DropboxFeedbackAdapter)} regularly checks if there are new files available (e.g., once a minute).
	The system will then create and send a message to the Splunk Peer Adapter which contains the location of the file and further information on the analysis (\texttt{3}\degree). Once Splunk has finished analyzing the data, Splunk will deposit the results file back to the Dropbox repository (\texttt{4}\degree~+~\texttt{5}\degree) and its \texttt{FeedbackPushAdapter} will push a multicast notification message to the COL1 members (\texttt{1}\degree~again). The COL1 can then continue their work.
%\FloatBarrier
\section{Related Work}
\label{sec:relwork}
  
  \mdl{} encompasses different design choices that, taken individually, can be compared with existing solutions. However, to the best of our knowledge, no existing system incorporates a similar set of functionalities as the one \mdl{} offers to support an effective virtualization of communication for dynamic, hybrid human-machine collectives.

  Popular Open-Source and proprietary Enterprise Service Buses and Integration Technologies provide the same support and flexibility for custom adapters as \mdl{} does. On the other hand, many ESBs lack the support of multi-tenancy (e.g., Apache ServiceMix \cite{ApacheServiceMix} and JBossESB \cite{JBoss}) or do have restrictions on implementing custom adapters (e.g., JBossESB \cite{JBoss}). Others do not support the dynamical enforcement of policies (e.g., WSO2 ESB \cite{WSO2}) and there is in general no support of the addressing of collectives at all which is one of the key features of \mdl{}. Furthermore the support of humans interacting with the system is generally not considered.

  Service-oriented CASs usually involve addressing peers as Web Services, lacking the ability to communicate with peers using different communication channels, especially external tools. For example, the ALLOW Ensembles project~\cite{Andrikopoulos} concentrates on the concept of cell ensembles, which consist of cells that have a defined behaviour. They use BPEL4Chor~\cite{BPEL4Chor} for the communication between cells, which allows communication between web services. 
  %Using additional extensions like WS-BPEL4People\cite{BPEL4People} or WS-HumanTask\cite{HumanTask} one could also incorporate human activities. Other approaches use an SQL like processing system\cite{Humanpowered} that makes use of human capabilities.
  The ASCENS project focuses on the peer-to-peer approach where some peers of the system know at least some other peers in the system~\cite{AutonomicCloud}. They use Pastry~\cite{Pastry} and extend it with the SCRIBE protocol~\cite{Scribe} to support any- and multi-casts. As previously shown, this behavior differs from ours, in that we do not support anycast, but multicast specifically within collective boundaries.
  %
  In~\cite{Cabri1}, authors propose a middleware that supports communication among agents on different platforms and programming languages. They use a different runtime for each platform and exchange messages between those runtimes to achieve a cross-platform communication of agents. Compared to our approach it focuses on the peer-to-peer interaction instead of the interaction of the system with peers. The intention of the middleware is to exchange the messages between the runtime systems compared to direct message exchange with peers in our approach.
  %
  Social Computing platforms like Jabberwocky~\cite{Jabberwocky} or TurKit~\cite{Turkit} utilize human capabilities to solve problems. However, they rely on existing crowdsourcing platforms and rely on their communication model that does not supporting collectives at all. 
  %Furthermore, support for inter-peer communication and collaboration is very restricted. 

\vspace{-5pt}

\section{Conclusions and Future Work}
\label{sec:conclusion}

  In this paper we presented \mdl{} -- a middleware aiming to tackle hybridity in a variety of aspects, including different kinds of supported computations (human- vs. machine-based service units), different channels of communication, and loose-coupling to promote use of familiar third-party services. This is of high importance in order to create a platform which is able to scale to a potentially high number of service units organized in multiple dynamic collectives. \mdl{} allows addressing collectives of service units transparently to the HDA-CAS, relieving the HDA-CAS programmer the duty to keep track of current members of a collective, allowing the collective to scale up and down when needed seamlessly. The described design was validated through a prototype implementation provided as open-source.
  %
  The focus of our future research will be on modelling the primitives for integrated monitoring and execution of elasticity actions, such as imposing of optimal topologies, dynamical adjustment of collective members, and support for incentive application. Currently, these actions have to be fully specified on the HDA-CAS (SmartSociety) application level, presenting an unnecessary burden for the developers.

\textbf{Acknowledgment: }
%\section*{Acknowledgment}
This work is supported by the EU FP7 SmartSociety project under grant N\textsuperscript{\underline{o}} 600854.

\vspace{-4pt}

% trigger a \newpage just before the given reference
% number - used to balance the columns on the last page
% adjust value as needed - may need to be readjusted if
% the document is modified later
%\IEEEtriggeratref{8}
% The "triggered" command can be changed if desired:
%\IEEEtriggercmd{\enlargethispage{-5in}}

% references section

% can use a bibliography generated by BibTeX as a .bbl file
% BibTeX documentation can be easily obtained at:
% http://www.ctan.org/tex-archive/biblio/bibtex/contrib/doc/
% The IEEEtran BibTeX style support page is at:
% http://www.michaelshell.org/tex/ieeetran/bibtex/
%\bibliographystyle{IEEEtran}
% argument is your BibTeX string definitions and bibliography database(s)
%\bibliography{IEEEabrv,../bib/paper}
%
% <OR> manually copy in the resultant .bbl file
% set second argument of \begin to the number of references
% (used to reserve space for the reference number labels box)
\begin{thebibliography}{1}

\bibitem{fausto}
F.~Giunchiglia, V.~Maltese, S.~Anderson, and D.~Miorandi. \emph{Towards Hybrid and Diversity-Aware Collective Adaptive Systems}, 2013. http://eprints.biblio.unitn.it/4214/

\bibitem{FoCASBook}
S.~Anderson et al. \emph{FoCAS Book: Adaptive Collective Systems – Herding Black Sheep}, Open publication, ISBN pending, 2013. http://focas.eu/documents/adaptive-collective-systems.pdf

\bibitem{SmartSocBook}
D.~Miorandi, V.~Maltese, M.~Rovatsos, A.~Nijholt, and J.~Stewart. \emph{Social Collective Intelligence: Combining the Powers of Humans and Machines to Build a Smarter Society}, ISBN 978-3-319-08680-4, Springer, 2014.

\bibitem{Cabri1}
G.~Cabri, E.~Domnori, and D.~Orlandini. \emph{Implementing Agent Interoperability between Language-Heterogeneous Platforms}, 20th IEEE Int. Workshop on Enabling Technologies: Infrastructure for Collaborative Enterprises, pp. 29--34, Paris, 2011.

\bibitem{JBoss} 
JBossESB. http://jbossesb.jboss.org/.

\bibitem{ApacheServiceMix}
Apache ServiceMix. http://servicemix.apache.org.

\bibitem{WSO2}
WSO2 ESB. http://wso2.com/.

\bibitem{Andrikopoulos}
A. V. Andrikopoulos, A. Bucchiarone, S. Gomez Saez, D. Karastoyanova, and C. Antares Mezzina. \emph{Towards Modelling and Execution of Collective Adaptive Systems}. Service-Oriented Computing–ICSOC 2013 Workshops. Springer, pp. 69--81, 2014.

\bibitem{BPEL4Chor}
G.~Decker, O.~Kopp, F.~Leymann, and M.~Weske \emph{BPEL4Chor: Extending BPEL for Modeling Choreographies}.  IEEE Int. Conference on Web Services 2007, pp. 296--303, IEEE, 2007.

\bibitem{AutonomicCloud}
P.~Mayer, A.~Klarl, R.~Hennicker, M.~Puviani, F.~Tiezzi, R.~Pugliese, J.~Keznikl, and T.~Bures. \emph{The Autonomic Cloud: A Vision of Voluntary, Peer-2-Peer Cloud Computing}. IEEE 7th Int. Conference on Self-Adaptation and Self-Organizing Systems Workshops, pp. 89--94, IEEE, 2013.

\bibitem{Pastry}
A.~Rowstron and P.~Druschel. \emph{Pastry: Scalable, decentralized object location, and routing for large-scale peer-to-peer systems}. Middleware 2001, Springer, 2001.

\bibitem{Scribe}
M.~Castro, P.~Druschel, A.-M.~Kermarrec, and A.~I.~Rowstron, \emph{Scribe: A large-scale and decentralized application-level multicast infrastructure}. IEEE J. on Selected Areas in Communications 20(8), pp. 1489--1499, 2002.

\bibitem{Jabberwocky}
S. Ahmad, A. Battle, Z. Malkani, and S. Kamvar. 2011. \emph{The jabberwocky programming environment for structured social computing}. Proc. 24th annual ACM symposium on User interface software and technology. ACM, 2011.

\bibitem{Turkit}
G.~Little, L.~B.~Chilton, M.~Goldman, and R.~C.~Miller. \emph{Turkit: tools for iterative tasks on mechanical turk}. Proc. ACM SIGKDD workshop on human computation, pp. 29--30, 2009.

\bibitem{truongijcis}
 H.-L. Truong, S.~Dustdar, and K.~Bhattacharya. \emph{Conceptualizing and Programming Hybrid Services in the Could}. Intl. J. of Cooperative Information Systems 22(4), 2013. 

\bibitem{KobiGal}
Y.~Gal, S.~Kraus, M.~Gelfand, H.~Khashan, and E.~Salmon. \emph{An Adaptive Agent for Negotiating with People in Different Cultures}. ACM Tran. on Intelligent Systems and Technology 3(1), ACM, 2011. 

\end{thebibliography}


\end{document}

%The following commented text is mine, so it can be freely used and altered

% A client-written SmartSociety application defines, among other things, a set of messages that can be exchanged with peers and their semantics. The application consists of two types of modules. A server-side module, running on SSP, and a module running on the peer device (actually, depending on the actual operating system that the peer uses we may have multiple types of peer apps, but for the sake of explanation, let us assume that only one exists). 

% As both modules belong to the same SS application, they have the common understanding of the message semantics which delimits what kind of interactions they can do. The messages they exchange can be used to propose working on a task, accept the work, quit, notify of changes, notify of incentives, send collaboration requests and messages to other collective members, etc. 

% We mentioned that the SSP should also set up a collaborative environment for a collective. However, this does not assume that the environment should be part of the peer application. Instead, the peer will just receive through her app the addresses and access credentials for using the different collaborative tools communication channels, and communicating with other peers. Communication with other peers in the collective through the predefined messages is done through SSP. So, all the message exchange that the application designer considers important for the application should go through SSP middleware, but if the application designer wishes so, a free peer-to-peer communication can be allowed. 

% For example, if the application promises paying out a referral bonus to a peer who brings in a quality collaborator in the collective, then this invitation to the collective must be done through SSP, in order that this action can be officially recorded and taken account of. On the other hand, free, unofficial communication of peers may be encouraged by automatically setting up an IRC chat room.
% Or, peers can be asked to send all official messages relevant to the collaboration to an official mailing list, which is managed by the SSP, while the unofficial communication channels may not be specified.

% Important thing here is to emphasize that no computation takes place within SSP or the peer module. Rather, the SSP only takes care of coordination and collaboration. Task descriptions, computation and utility tools and most communication channels lie outside of the SSP platform on user defined locations. SSP just coordinates and monitors the execution. 
% For example, if for participating in a collective a number of peers were issued credentials to access a dropbox folder by the SSP application, then excluding a peer includes also revoking access rights to that folder. 

%SmartSociety applications will be accessible via a variety of devices, online via the web and on mobile device